定时器是怎么实现的？还有什么实现方式？
>> 答：   
>> * 理解定时器： 很多场景会使用到定时器，例如     
>> 1.使用TCP长连接时，客户端需要定时向服务端发送心跳请求。   
>> 2.财务系统每个月的月末定时生成对账单。  
>> 3.双11的0点，定时开启秒杀开关。   
>> * 一般定时任务的形式表现为：经过固定时间后触发、按固定频率周期性触发、在某个时刻触发。
定时器可以理解为这样一个数据结构：存储一系列的任务集合，并且Deadline越接近的任务，
拥有越高的执行优先级，在用户视角支持以下几种操作：NewTask:将新任务加入任务集合，
Cancel：取消某个任务，在任务调度视角还要支持：Run:执行一个到期的定时任务，判断一个
任务是否到期，基本会采用轮询的方式进行过，每隔一个时间片去检查最近的任务是否到期，并且在
NewTask和Cancel的行为发生后，任务调度策略也会出现调整。  
>> * 数据结构的选择包括：1. 双向有序链表，2. 堆， 3. 时间轮， 4.层级时间轮。   
>> * 常见的实现
>> 1. JDK Timer: 使用Timer实现任务调度的核心是Timer和TimerTask。其中Timer
负责设定TimerTask的起始和间隔执行时间。使用者只需要创建一个TimerTask的继承类，
实现自己的run方式，然后丢给Timer去执行即可。其中Timer::TaskQueue是使用数组
实现的一个简易的堆。其缺陷是a.只能被单线程调度，b.TimerTask中出现的异常会影响到
Timer的执行。  
>> 2. JDK ScheduledExecutorService： 解决了同一个定时器调度多个任务的阻塞问题，
并且任务异常不会中断ScheduledExecutorService。底层使用的数据结构为堆。
>> 3. JDK HashedWheelTimer。

>> [参考网址 1](https://bingtaoli.github.io/2017/06/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/)   
>> [参考网址 2](https://www.cnkirito.moe/timer/)   
>> [参考网址 3](https://liqiang.io/post/four-way-to-implement-linux-cron)    
>> [参考网址 4](https://blog.csdn.net/thisinnocence/article/details/81073117)     
>> [参考网址 5 代码实现](https://liqiang.io/post/four-way-to-implement-linux-cron)

[实现一个无锁队列(用原子操作)](https://www.cnblogs.com/catch/tag/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/)
```cpp
typedef struct _Node Node;
typedef struct _Queue Queue;

struct _Node {
    void *data;
    Node *next;
};

struct _Queue {
    Node *head;
    Node *tail;
};

Queue*
queue_new(void)
{
    Queue *q = g_slice_new(sizeof(Queue));
    q->head = q->tail = g_slice_new0(sizeof(Node));
    return q;
}

void
queue_enqueue(Queue *q, gpointer data)
{
    Node *node, *tail, *next;

    node = g_slice_new(Node);
    node->data = data;
    node->next = NULL;

    while (TRUE) {
        tail = q->tail;
        next = tail->next; // 改为 q->tail->next 会更好
        if (tail != q->tail)    // 保证tail指向的是链表的末尾，因为期间会有别的线程插入
            continue;

        if (next != NULL) {     // 如果别的线程又有新的节点插入了
            CAS(&q->tail, tail, next);
            continue;
        }

        if (CAS(&tail->next, null, node) // 应改为 CAS(&q->tail->next, null, node)
            break;
    }

    CAS(&q->tail, tail, node);
}

gpointer
queue_dequeue(Queue *q)
{
    Node *node, *tail, *next;

    while (TRUE) {
        head = q->head;
        tail = q->tail;
        next = head->next; // 应改为 q->head->next
        if (head != q->head)    // 保证head指向开头，因为期间会有别的线程取
            continue;

        if (next == NULL)
            return NULL; // Empty

        if (head == tail) {
            CAS(&q->tail, tail, next); // next 不空，head == tail, 即 tail 并没有指向真正的尾巴
            continue;
        }

        data = next->data;
        if (CAS(&q->head, head, next))
            break;
    }

    g_slice_free(Node, head); // This isn't safe
    return data;
}

1. memory reclamation 内存释放问题： 创建队列的时候，分配好全部的内存。
2. ABA问题: 给节点做标志，使得每个插入的节点有一个唯一的标记，这样，就能检测当前的节点是否已发生变化。
```

网络库的io模型是怎么样的，为什么这个io模型是高性能的？
>> UNP中总结的IO模型有5种之多：阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO。前四种都属于同步IO。阻塞IO不必说了。非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。
   异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程。
  
>> Reactor[one loop per thread: non-blocking + IO multiplexing]模型。muduo采用的是Reactors in thread有一个main Reactor负责accept(2)连接，然后把连接挂在某个sub Reactor中(muduo中采用的是round-robin的方式来选择sub Reactor)，这样该连接的所有操作都在那个sub Reactor所处的线程中完成。多个连接可能被分到多个线程中，以充分利用CPU。

>> muduo采用的是固定大小的Reactor pool，池子的大小通常根据CPU数目确定。也就是说线程数固定，这样程序的总体处理能力不会随连接数增加而下降。另外一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满8个核(如果需要优化突发请求，可以考虑Reactors + thread pool)。这种方案把IO分派给多个线程，防止出现一个Reactor的处理能力饱和。
   
![各种IO模型的比较](https://github.com/834810071/muduo_study/blob/master/book_study/0_1280551552NVgW.jpg "各种IO模型的比较")

>> [参考网址 1](https://www.cnblogs.com/findumars/p/6361627.html)   
>> [参考网址 2](https://blog.csdn.net/WuLex/article/details/80615699)
>> [muduo网络库：Reactor模型的介绍](https://blog.csdn.net/weixin_43819197/article/details/92828590)

muduo的多线程体现在什么地方？

muduo的主线程accept的fd如何分发给其他线程？

muduo的定时器如何实现？

muduo如何限制连接的数量？

muduo如何设计buffer？

muduo的定时器是如何设计的？
>> 答:   
>> * muduo的定时器功能由三个class实现，TimerId、Timer、TimerQueue，用户只能看到第一个class，另外两个都是内部实现细节。其中TimerQueue最重要的接口包括addTimer()添加定时任务和cancel()取消定时任务。  

>> * muduo把定时器交给内核管理，利用linux内核提供的timerfd_create接口创建定时器。     
   
>> * muduo中定义了TimerQueue类作为定时器的封装。初始化时候，通过linux的API创建timerfd。定义一个timers来存储timer,这个timers的存储结构是std::Set，元素是std::pair<Timerstamp, Timer*>，添加定时器则往timers添加，muduo使用的是set存储定时器，set是默认排序的，最早超时的会在最前面，即set.begin()为最早超时的定时器。   
   
>> * 获取超时任务是通过getExpired函数实现的，其具体实现是根据传入的参数设置一个哨兵值，然后调用set::lower_bound()返回第一个未到期的Timer的迭代器，
之后在timers_中删除到期的任务，并返回到期的任务。muduo使用linux的API创建定时触发可读的timerfd_,fd触发时调用handleRead函数，
该函数调用getExpired获取超时定时器，并逐一执行。  

>> * cancel()通过给每个Timer对象添加一个全局递增序列号，区分地址相同的先后两个Timer对象。增加activeTimers_成员变量，保存的是目前有效的Timer指针，并满足timers_.size() == activeTimers_.size()，元素是pair<Timer*, int64_t>。并且利用callingExpiredTimers_和cancelingTimers_防止“自注销”现象，即定时器回调中注销当前定时器。 

如何安全的关闭tcp连接，能不能直接close，如何直接close会发生什么？

muduo是如何 线程安全的对 对象的声明周期进行管理？
